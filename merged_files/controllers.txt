

========== File: app/Http/Controllers/AdminController.php ==========
<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Master;
use App\Models\Client;
use App\Models\Project;
use App\Models\Tariff;
use App\Models\Payment;
use App\Models\DailyScheduleTemplate;

class AdminController extends Controller
{
    public function __construct()
    {
        $this->middleware('auth:web');
    }

    public function dashboard()
    {
        $users = User::count();
        $masters = Master::count();
        $clients = Client::count();
        $projects = Project::count();
        return view('admin.dashboard', compact('users', 'masters', 'clients', 'projects'));
    }

    public function users()
    {
        $users = User::all();
        return view('admin.users', compact('users'));
    }

    public function masters()
    {
        $masters = Master::with('projects')->get();
        return view('admin.masters', compact('masters'));
    }

    public function clients()
    {
        $clients = Client::with('bookings')->get();
        return view('admin.clients', compact('clients'));
    }

    public function projects()
    {
        $projects = Project::with(['master', 'categories', 'dailySchedules', 'dailyScheduleTemplates'])->get();
        return view('admin.projects', compact('projects'));
    }

    public function tariffs()
    {
        $tariffs = Tariff::with('masterTariffs')->get();
        return view('admin.tariffs', compact('tariffs'));
    }

    public function payments()
    {
        $payments = Payment::with(['master', 'tariff'])->get();
        return view('admin.payments', compact('payments'));
    }
}


========== File: app/Http/Controllers/Auth/AdminAuthController.php ==========
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class AdminAuthController extends Controller
{
    public function showLoginForm()
    {
        return view('admin.auth.login');
    }

    public function login(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::guard('web')->attempt(['email' => $request->email, 'password' => $request->password])) {
            return redirect()->route('admin.dashboard');
        }

        return redirect()->back()->withErrors(['email' => 'Неверные учетные данные']);
    }

    public function logout(Request $request)
    {
        Auth::guard('web')->logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/admin/login');
    }
}


========== File: app/Http/Controllers/Auth/ClientAuthController.php ==========
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\OtpCode;
use App\Models\Client;
use App\Models\ClientAuthProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Str;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;

class ClientAuthController extends Controller
{
    public function showLoginForm()
    {
        return view('client.auth.login');
    }

    public function sendCode(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        OtpCode::where('identifier', $request->email)->where('type', 'email')->delete();

        $code = '';
        for ($i = 0; $i < 6; $i++) {
            $code .= (string)rand(0, 9);
        }
        $code = "123456";
        OtpCode::create([
            'identifier' => $request->email,
            'type' => 'email',
            'code' => Hash::make($code),
            'expires_at' => Carbon::now()->addMinutes(5),
        ]);

        Mail::raw("Ваш код подтверждения: $code", function ($message) use ($request) {
            $message->to($request->email)->subject('Код подтверждения YourOrd');
        });

        return redirect()->route('client.auth.verify-form')->with([
            'message' => 'Код отправлен',
            'email' => $request->email,
        ]);
    }

    public function showVerifyForm()
    {
        return view('client.auth.verify-code');
    }

    public function verifyCode(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
            'code' => 'required|string',
        ]);

        $otp = OtpCode::where('identifier', $request->email)
            ->where('type', 'email')
            ->where('used', false)
            ->where('expires_at', '>', Carbon::now())
            ->first();

        if ($otp && Hash::check($request->code, $otp->code)) {
            $otp->update(['used' => true]);

            $client = Client::where('email', $request->email)->first();
            if (!$client) {
                $client = Client::create(['email' => $request->email]);
            }

            ClientAuthProvider::updateOrCreate(
                [
                    'client_id' => $client->id,
                    'provider' => 'email',
                    'provider_id' => $request->email,
                ]
            );

            Auth::guard('client')->login($client);
            return redirect()->route('client.dashboard');
        }

        return redirect()->back()->withErrors(['code' => 'Неверный или истекший код']);
    }

    public function logout(Request $request)
    {
        Auth::guard('client')->logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/client/login');
    }
}


========== File: app/Http/Controllers/Auth/MasterAuthController.php ==========
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\OtpCode;
use App\Models\Master;
use App\Models\MasterAuthProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Str;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;

class MasterAuthController extends Controller
{
    public function showLoginForm()
    {
        return view('master.auth.login');
    }

    public function sendCode(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        OtpCode::where('identifier', $request->email)->where('type', 'email')->delete();

        $code = '';
        for ($i = 0; $i < 6; $i++) {
            $code .= (string)rand(0, 9);
        }
        $code = "123456";
        OtpCode::create([
            'identifier' => $request->email,
            'type' => 'email',
            'code' => Hash::make($code),
            'expires_at' => Carbon::now()->addMinutes(5),
        ]);

        Mail::raw("Ваш код подтверждения: $code", function ($message) use ($request) {
            $message->to($request->email)->subject('Код подтверждения YourOrd');
        });

        return redirect()->route('master.auth.verify-form')->with([
            'message' => 'Код отправлен',
            'email' => $request->email,
        ]);
    }

    public function showVerifyForm()
    {
        return view('master.auth.verify-code');
    }

    public function verifyCode(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
            'code' => 'required|string',
        ]);

        $otp = OtpCode::where('identifier', $request->email)
            ->where('type', 'email')
            ->where('used', false)
            ->where('expires_at', '>', Carbon::now())
            ->first();

        if ($otp && Hash::check($request->code, $otp->code)) {
            $otp->update(['used' => true]);

            $master = Master::where('email', $request->email)->first();
            if (!$master) {
                $master = Master::create(['email' => $request->email]);
            }

            MasterAuthProvider::updateOrCreate(
                [
                    'master_id' => $master->id,
                    'provider' => 'email',
                    'provider_id' => $request->email,
                ]
            );

            Auth::guard('master')->login($master);
            return redirect()->route('master.dashboard');
        }

        return redirect()->back()->withErrors(['code' => 'Неверный или истекший код']);
    }

    public function logout(Request $request)
    {
        Auth::guard('master')->logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/master/login');
    }
}


========== File: app/Http/Controllers/BookingController.php ==========
<?php

namespace App\Http\Controllers;

use App\Models\Booking;
use App\Models\Project;
use App\Models\Service;
use App\Models\Schedule;
use App\Models\Blacklist;
use Illuminate\Http\Request;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;

class BookingController extends Controller
{
    public function clientDashboard()
    {
        return view('client.dashboard');
    }

    public function clientBookings()
    {
        $bookings = Booking::where('client_id', Auth::guard('client')->id())
            ->with(['service', 'schedule', 'project'])
            ->get();
        return view('client.bookings', compact('bookings'));
    }

    public function create(Request $request)
    {
        $request->validate([
            'project_id' => 'required|exists:projects,id',
            'service_id' => 'required|exists:services,id',
            'schedule_id' => 'required|exists:schedules,id',
        ]);

        $service = Service::findOrFail($request->service_id);
        $schedule = Schedule::findOrFail($request->schedule_id);

        // Проверка длительности
        $startTime = Carbon::parse($schedule->start_time);
        $endTime = $startTime->copy()->addMinutes($service->duration);
        if ($endTime > $schedule->end_time) {
            return redirect()->back()->withErrors(['time' => 'Услуга не помещается в слот']);
        }

        // Проверка перерывов
        $nextBreak = Schedule::where('project_id', $request->project_id)
            ->where('type', 'break')
            ->where('start_time', '>=', $startTime)
            ->orderBy('start_time')
            ->first();
        if ($nextBreak && $nextBreak->floating_break_buffer) {
            $bufferTime = $startTime->copy()->addMinutes($nextBreak->floating_break_buffer);
            if ($endTime > $bufferTime) {
                return redirect()->back()->withErrors(['time' => 'Услуга не помещается до перерыва']);
            }
        }

        // Проверка конфликтов
        if (Booking::where('schedule_id', $request->schedule_id)->where('status', 'confirmed')->exists()) {
            return redirect()->back()->withErrors(['time' => 'Время занято']);
        }

        // Проверка черного списка
        $client = Auth::guard('client')->user();
        if (Blacklist::where('master_id', $schedule->master_id)->where('client_email', $client->email)->exists()) {
            return redirect()->back()->withErrors(['client_email' => 'Вы в черном списке']);
        }

        Booking::create([
            'project_id' => $request->project_id,
            'client_id' => $client->id,
            'client_email' => $client->email,
            'service_id' => $request->service_id,
            'schedule_id' => $request->schedule_id,
            'status' => 'pending',
        ]);

        return redirect()->route('client.bookings')->with('message', 'Запись создана');
    }
}


========== File: app/Http/Controllers/ClientAuthController.php ==========
<?php
namespace App\Http\Controllers;

use App\Models\Client;
use App\Models\SmsCode;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Twilio\Rest\Client as TwilioClient;

class ClientAuthController extends Controller
{
    public function showLoginForm()
    {
        return view('client.auth.login');
    }

    public function login(Request $request)
    {
        $request->validate([
            'phone' => 'required|string',
            'password' => 'nullable|string',
        ]);

        $client = Client::where('phone', $request->phone)->first();
        if (!$client) {
            return back()->withErrors(['phone' => 'Клиент не найден']);
        }

        if ($request->password && Auth::guard('client')->attempt(['phone' => $request->phone, 'password' => $request->password])) {
            return redirect()->route('client.dashboard');
        }

        $code = rand(100000, 999999);
        SmsCode::create([
            'user_type' => 'client',
            'user_id' => $client->id,
            'phone' => $client->phone,
            'code' => $code,
            'expires_at' => now()->addMinutes(10),
        ]);

        $twilio = new TwilioClient(config('services.twilio.sid'), config('services.twilio.token'));
        $twilio->messages->create($client->phone, [
            'from' => config('services.twilio.from'),
            'body' => "Ваш код для входа: $code",
        ]);

        session(['login_phone' => $client->phone]);
        return redirect()->route('client.auth.verify');
    }

    public function showVerifyCodeForm()
    {
        return view('client.auth.verify');
    }

    public function verifyCode(Request $request)
    {
        $request->validate(['code' => 'required|string|size:6']);
        $phone = session('login_phone');
        if (!$phone) {
            return redirect()->route('client.auth.login')->withErrors(['code' => 'Сессия истекла']);
        }

        $smsCode = SmsCode::where('user_type', 'client')
            ->where('phone', $phone)
            ->where('code', $request->code)
            ->where('expires_at', '>=', now())
            ->first();

        if (!$smsCode) {
            return back()->withErrors(['code' => 'Неверный или просроченный код']);
        }

        $client = Client::where('phone', $phone)->first();
        Auth::guard('client')->login($client);
        $smsCode->delete();
        session()->forget('login_phone');
        return redirect()->route('client.dashboard');
    }

    public function logout()
    {
        Auth::guard('client')->logout();
        return redirect()->route('client.auth.login');
    }
}


========== File: app/Http/Controllers/ClientController.php ==========
<?php
namespace App\Http\Controllers;

use App\Models\Project;
use App\Models\Service;
use App\Models\DailySchedule;
use App\Models\Booking;
use App\Models\WorkBreak;
use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;

class ClientController extends Controller
{
    public function __construct()
    {
        $this->middleware('auth:client')->except(['projects', 'showProject']);
    }

    public function dashboard(Request $request)
    {
        Log::info('ClientController::dashboard started', ['params' => $request->all()]);
        $client = Auth::guard('client')->user();
        $query = Booking::where('client_id', $client->id)
            ->with(['project', 'service', 'dailySchedule'])
            ->orderBy('start_time', 'desc');

        if ($request->has('status') && in_array($request->status, ['pending', 'confirmed', 'cancelled'])) {
            $query->where('status', $request->status);
        }
        if ($request->has('date')) {
            $query->whereHas('dailySchedule', function ($q) use ($request) {
                $q->where('date', $request->date);
            });
        }

        $bookings = $query->paginate(10);
        Log::info('ClientController::dashboard completed', ['bookings_count' => $bookings->count()]);
        return view('client.dashboard', compact('client', 'bookings'));
    }

    public function projects(Request $request)
    {
        $projects = Auth::guard('client')->user()->projects()->with('specialists')->paginate(10);
        return view('client.projects', compact('projects'));
    }

    public function showProject($slug, Request $request)
    {
        Log::info('ClientController::showProject started', ['slug' => $slug, 'params' => $request->all()]);
        $project = Project::where('slug', $slug)
            ->with(['services' => function ($query) {
                $query->select('id', 'project_id', 'name', 'duration', 'price', 'category_id');
            }, 'categories'])
            ->firstOrFail();
        $categories = $project->categories;
        $services = $project->services;
        $date = $request->input('date', now()->format('Y-m-d'));

        $slotsByService = [];
        foreach ($services as $service) {
            $slotsByService[$service->id] = $this->getAvailableSlots($project, $service, $date);
        }

        Log::info('ClientController::showProject completed', ['slots_count' => count($slotsByService)]);
        return view('client.project', compact('project', 'categories', 'services', 'slotsByService', 'date'));
    }

    protected function getAvailableSlots(Project $project, Service $service, $date)
    {
        Log::info('getAvailableSlots started', [
            'project_id' => $project->id,
            'service_id' => $service->id,
            'date' => $date,
            'service_duration' => $service->duration
        ]);

        $minDuration = Service::where('project_id', $project->id)->min('duration') ?? 30;
        $slotStep = $minDuration;

        $dailySchedule = DailySchedule::where('project_id', $project->id)
            ->where('date', $date)
            ->where('is_working_day', true)
            ->select('id', 'project_id', 'start_time', 'end_time')
            ->first();

        if (!$dailySchedule) {
            Log::warning('No daily schedule found', ['project_id' => $project->id, 'date' => $date]);
            return [];
        }

        $bookings = Booking::where('project_id', $project->id)
            ->where('daily_schedule_id', $dailySchedule->id)
            ->select('id', 'start_time', 'service_id')
            ->with(['service' => function ($query) {
                $query->select('id', 'duration');
            }])
            ->get();

        $breaks = WorkBreak::where('daily_schedule_id', $dailySchedule->id)
            ->select('id', 'start_time', 'end_time')
            ->get();

        $slots = [];
        $currentTime = Carbon::parse($date . ' ' . $dailySchedule->start_time);
        $endTime = Carbon::parse($date . ' ' . $dailySchedule->end_time);
        $duration = $service->duration;
        $iterationCount = 0;

        Log::debug('getAvailableSlots params', [
            'currentTime' => $currentTime->toDateTimeString(),
            'endTime' => $endTime->toDateTimeString(),
            'slotStep' => $slotStep,
            'service_duration' => $duration,
            'min_duration' => $minDuration,
            'bookings_count' => $bookings->count(),
            'breaks_count' => $breaks->count()
        ]);

        while ($currentTime->lte($endTime->copy()->subMinutes($duration)) && $iterationCount < 1000) {
            $slotEnd = $currentTime->copy()->addMinutes($duration);
            $isFree = true;

            foreach ($bookings as $booking) {
                $bookingStart = Carbon::parse($booking->start_time);
                $bookingEnd = $bookingStart->copy()->addMinutes($booking->service->duration);
                if ($currentTime->lt($bookingEnd) && $slotEnd->gt($bookingStart)) {
                    $isFree = false;
                    Log::debug('Slot overlaps with booking', [
                        'slot_start' => $currentTime->toDateTimeString(),
                        'slot_end' => $slotEnd->toDateTimeString(),
                        'booking_start' => $bookingStart->toDateTimeString(),
                        'booking_end' => $bookingEnd->toDateTimeString()
                    ]);
                    break;
                }
            }

            foreach ($breaks as $break) {
                $breakStart = Carbon::parse($date . ' ' . $break->start_time);
                $breakEnd = Carbon::parse($date . ' ' . $break->end_time);
                if ($currentTime->lt($breakEnd) && $slotEnd->gt($breakStart)) {
                    $isFree = false;
                    Log::debug('Slot overlaps with break', [
                        'slot_start' => $currentTime->toDateTimeString(),
                        'slot_end' => $slotEnd->toDateTimeString(),
                        'break_start' => $breakStart->toDateTimeString(),
                        'break_end' => $breakEnd->toDateTimeString()
                    ]);
                    break;
                }
            }

            if ($isFree && $currentTime->gte(Carbon::parse($date . ' ' . $dailySchedule->start_time)) && $slotEnd->lte($endTime)) {
                $slots[] = [
                    'start' => $currentTime->format('H:i'),
                    'end' => $slotEnd->format('H:i'),
                ];
                Log::debug('Slot added', [
                    'start' => $currentTime->format('H:i'),
                    'end' => $slotEnd->format('H:i')
                ]);
            }

            $currentTime = $this->getNextSlotTime($currentTime, $slotStep, $bookings, $breaks, $dailySchedule, $service, $date);
            $iterationCount++;
            Log::debug('Next slot time', ['currentTime' => $currentTime->toDateTimeString()]);
        }

        if ($iterationCount >= 1000) {
            Log::error('Possible infinite loop in getAvailableSlots', ['project_id' => $project->id, 'service_id' => $service->id]);
        }

        Log::info('getAvailableSlots completed', ['slots_count' => count($slots)]);
        return $slots;
    }

    protected function getNextSlotTime(Carbon $currentTime, int $slotStep, $bookings, $breaks, DailySchedule $dailySchedule, Service $service, $date): Carbon
    {
        $scheduleStart = Carbon::parse($date . ' ' . $dailySchedule->start_time);
        $scheduleEnd = Carbon::parse($date . ' ' . $dailySchedule->end_time);
        $nextTime = $currentTime->copy();
        $roundingInterval = 15;

        Log::debug('getNextSlotTime started', [
            'currentTime' => $currentTime->toDateTimeString(),
            'slotStep' => $slotStep
        ]);

        $slotEnd = $nextTime->copy()->addMinutes($service->duration);
        $latestEnd = $nextTime;
        $lastBookingDuration = null;

        foreach ($bookings as $booking) {
            $bookingStart = Carbon::parse($booking->start_time);
            $bookingEnd = $bookingStart->copy()->addMinutes($booking->service->duration);
            if ($currentTime->lt($bookingEnd) && $slotEnd->gt($bookingStart)) {
                if ($bookingEnd->gt($latestEnd)) {
                    $latestEnd = $bookingEnd->copy();
                    $lastBookingDuration = $booking->service->duration;
                }
                Log::debug('Overlap with booking', [
                    'booking_start' => $bookingStart->toDateTimeString(),
                    'booking_end' => $bookingEnd->toDateTimeString(),
                    'current_slot_start' => $currentTime->toDateTimeString(),
                    'current_slot_end' => $slotEnd->toDateTimeString()
                ]);
            }
        }

        foreach ($breaks as $break) {
            $breakStart = Carbon::parse($date . ' ' . $break->start_time);
            $breakEnd = Carbon::parse($date . ' ' . $break->end_time);
            if ($currentTime->lt($breakEnd) && $slotEnd->gt($breakStart)) {
                if ($breakEnd->gt($latestEnd)) {
                    $latestEnd = $breakEnd->copy();
                    $lastBookingDuration = null;
                }
                Log::debug('Overlap with break', [
                    'break_start' => $breakStart->toDateTimeString(),
                    'break_end' => $breakEnd->toDateTimeString(),
                    'current_slot_start' => $currentTime->toDateTimeString(),
                    'current_slot_end' => $slotEnd->toDateTimeString()
                ]);
            }
        }

        if ($latestEnd->gt($nextTime)) {
            $nextTime = $latestEnd->copy();
            Log::debug('Adjusted to latest end', ['new_next_time' => $nextTime->toDateTimeString()]);
            if ($lastBookingDuration && ($lastBookingDuration % 15 !== 0)) {
                $minutes = $nextTime->minute;
                $roundedMinutes = ceil($minutes / $roundingInterval) * $roundingInterval;
                $nextTime->setMinutes($roundedMinutes);
                if ($roundedMinutes >= 60) {
                    $nextTime->addHour()->setMinutes(0);
                }
                Log::debug('Rounded to 15-minute interval', [
                    'original_minutes' => $minutes,
                    'rounded_minutes' => $roundedMinutes,
                    'nextTime_rounded' => $nextTime->toDateTimeString()
                ]);
            }
        } else {
            $nextTime->addMinutes($slotStep);
            Log::debug('Added slotStep', ['new_next_time' => $nextTime->toDateTimeString(), 'slotStep' => $slotStep]);
        }

        return $nextTime;
    }

    public function createBooking(Request $request, $slug)
    {
        Log::info('createBooking started', ['slug' => $slug, 'input' => $request->all()]);

        $request->validate([
            'date' => 'required|date',
            'slot_start' => 'required',
            'service_id' => 'required|exists:services,id',
        ]);

        $project = Project::where('slug', $slug)->firstOrFail();
        $service = Service::findOrFail($request->service_id);
        $dailySchedule = DailySchedule::where('project_id', $project->id)
            ->where('date', $request->date)
            ->firstOrFail();

        $startTime = Carbon::parse($request->date . ' ' . $request->slot_start);

        $booking = Booking::create([
            'project_id' => $project->id,
            'service_id' => $service->id,
            'client_id' => Auth::guard('client')->id(),
            'daily_schedule_id' => $dailySchedule->id,
            'start_time' => $startTime,
            'status' => 'pending',
        ]);

        Log::info('Booking created', ['booking_id' => $booking->id]);
        return redirect()->route('client.project', $slug)->with('message', 'Запись создана');
    }

    public function bookings(Request $request)
    {
        Log::info('ClientController::bookings started', ['params' => $request->all()]);
        $client = Auth::guard('client')->user();
        $query = Booking::where('client_id', $client->id)
            ->with(['project', 'service', 'dailySchedule'])
            ->orderBy('start_time', 'desc');

        if ($request->has('status') && in_array($request->status, ['pending', 'confirmed', 'cancelled'])) {
            $query->where('status', $request->status);
        }
        if ($request->has('date')) {
            $query->whereHas('dailySchedule', function ($q) use ($request) {
                $q->where('date', $request->date);
            });
        }

        $bookings = $query->paginate(10);
        Log::info('ClientController::bookings completed', ['bookings_count' => $bookings->count()]);
        return view('client.bookings', compact('bookings'));
    }

    public function addProjectToFavorites(Request $request, $slug)
    {
        Log::info('addProjectToFavorites started', ['slug' => $slug]);
        $project = Project::where('slug', $slug)->firstOrFail();
        $client = Auth::guard('client')->user();
        if ($client->projects()->where('project_id', $project->id)->exists()) {
            $client->projects()->detach($project->id);
            $message = 'Проект удалён из избранного';
        } else {
            $client->projects()->syncWithoutDetaching([$project->id]);
            $message = 'Проект добавлен в избранное';
        }
        Log::info('Project favorite toggled', ['project_id' => $project->id, 'client_id' => $client->id]);
        return redirect()->route('client.project', $slug)->with('message', $message);
    }

    public function cancelBooking(Request $request, Booking $booking)
    {
        Log::info('cancelBooking started', ['booking_id' => $booking->id]);
        if ($booking->client_id !== Auth::guard('client')->id()) {
            return response()->json(['error' => 'Недостаточно прав для отмены'], 403);
        }
        $booking->update(['status' => 'cancelled']);
        Log::info('Booking cancelled', ['booking_id' => $booking->id]);
        return response()->json(['message' => 'Запись отменена']);
    }
}


========== File: app/Http/Controllers/Controller.php ==========
<?php

namespace App\Http\Controllers;

use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Foundation\Bus\DispatchesJobs;
use Illuminate\Foundation\Validation\ValidatesRequests;
use Illuminate\Routing\Controller as BaseController;

class Controller extends BaseController
{
    use AuthorizesRequests, DispatchesJobs, ValidatesRequests;
}


========== File: app/Http/Controllers/ProjectController.php ==========
<?php
namespace App\Http\Controllers;

use App\Models\Project;
use App\Models\Specialist;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class ProjectController extends Controller
{
    public function index()
    {
        $specialist = Auth::guard('specialist')->user();
        $projects = $specialist->projects()->get();
        return view('specialist.projects', compact('projects'));
    }

    public function create()
    {
        return view('specialist.projects.create');
    }

    public function store(Request $request)
    {
        $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
            'client_id' => 'required|exists:clients,id',
        ]);

        $project = Project::create([
            'title' => $request->title,
            'description' => $request->description,
            'client_id' => $request->client_id,
        ]);

        // Привязываем проект к специалисту
        $specialist = Auth::guard('specialist')->user();
        $project->specialists()->attach($specialist->id, [
            'is_owner' => true,
            'permissions' => json_encode(['manage_tasks', 'view_details']),
        ]);

        return redirect()->route('specialist.projects')->with('success', 'Проект успешно создан.');
    }
}


========== File: app/Http/Controllers/ScheduleController.php ==========
<?php

namespace App\Http\Controllers;

use App\Models\Schedule;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class ScheduleController extends Controller
{
    public function index()
    {
        $schedules = Schedule::where('master_id', Auth::guard('master')->id())->with('project')->get();
        return view('master.schedules', compact('schedules'));
    }

    public function store(Request $request)
    {
        $request->validate([
            'project_id' => 'required|exists:projects,id',
            'start_time' => 'required|date',
            'end_time' => 'required|date|after:start_time',
            'type' => 'required|in:work,break,day_off',
            'floating_break_buffer' => 'nullable|integer|min:0',
        ]);

        Schedule::create([
            'project_id' => $request->project_id,
            'master_id' => Auth::guard('master')->id(),
            'start_time' => $request->start_time,
            'end_time' => $request->end_time,
            'type' => $request->type,
            'floating_break_buffer' => $request->floating_break_buffer,
        ]);

        return redirect()->route('master.schedules')->with('message', 'Слот добавлен');
    }
}


========== File: app/Http/Controllers/SpecialistAuthController.php ==========
<?php
namespace App\Http\Controllers;

use App\Models\Specialist;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Session;

class SpecialistAuthController extends Controller
{
    public function showLoginForm()
    {
        return view('specialist.auth.login');
    }

    public function login(Request $request)
    {
        $request->validate([
            'phone' => 'required|string|regex:/^\+?[1-9]\d{1,14}$/',
        ]);

        $specialist = Specialist::where('phone', $request->phone)->first();

        if (!$specialist) {
            $specialist = Specialist::create([
                'phone' => $request->phone,
                'name' => null,
                'email' => null,
                'password' => null,
            ]);
        }

        Session::put('phone', $request->phone);
        Session::put('phone_step', true);

        return redirect()->route('specialist.login')->with('success', 'Код отправлен на ваш номер. Для тестирования используйте код: 123456');
    }

    public function verifyCode(Request $request)
    {
        $request->validate([
            'code' => 'required|string|size:6',
        ]);

        $phone = Session::get('phone');

        if (!$phone) {
            return redirect()->route('specialist.login')->withErrors(['phone' => 'Сессия истекла. Введите номер телефона заново.']);
        }

        if ($request->code !== '123456') {
            return back()->withErrors(['code' => 'Неверный код.'])->withInput();
        }

        $specialist = Specialist::where('phone', $phone)->first();

        if (!$specialist) {
            return redirect()->route('specialist.login')->withErrors(['phone' => 'Специалист не найден.']);
        }

        Auth::guard('specialist')->login($specialist);
        Session::forget(['phone', 'phone_step']);

        return redirect()->route('specialist.dashboard');
    }

    public function showRegisterForm()
    {
        return view('specialist.auth.register');
    }

    public function register(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:specialists',
            'phone' => 'required|string|regex:/^\+?[1-9]\d{1,14}$/|unique:specialists',
            'password' => 'required|string|min:8|confirmed',
        ]);

        $specialist = Specialist::create([
            'name' => $request->name,
            'email' => $request->email,
            'phone' => $request->phone,
            'password' => Hash::make($request->password),
        ]);

        Auth::guard('specialist')->login($specialist);

        return redirect()->route('specialist.dashboard');
    }

    public function logout(Request $request)
    {
        Auth::guard('specialist')->logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect()->route('specialist.login');
    }
}


========== File: app/Http/Controllers/SpecialistController.php ==========
<?php
namespace App\Http\Controllers;

use App\Models\Project;
use App\Models\Specialist;
use App\Models\Invitation;
use App\Models\Booking;
use App\Models\Service;
use App\Models\DailySchedule;
use App\Models\WorkBreak;
use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use App\Mail\InvitationMail;
use Illuminate\Support\Facades\Mail;

class SpecialistController extends Controller
{
    public function __construct()
    {
        $this->middleware('auth:specialist')->except(['viewInvitation', 'acceptInvitation']);
    }

    public function dashboard(Request $request)
    {
        Log::info('SpecialistController::dashboard started', ['params' => $request->all()]);
        $specialist = Auth::guard('specialist')->user();
        $projects = $specialist->projects()->with('specialists')->paginate(10);
        Log::info('SpecialistController::dashboard completed', ['projects_count' => $projects->count()]);
        return view('specialist.dashboard', compact('specialist', 'projects'));
    }

    public function projects(Request $request)
    {
        $projects = Auth::guard('specialist')->user()->projects()->with('specialists')->paginate(10);
        return view('specialist.projects', compact('projects'));
    }

    public function showProject($slug, Request $request)
    {
        Log::info('SpecialistController::showProject started', ['slug' => $slug, 'params' => $request->all()]);
        $project = Project::where('slug', $slug)->with(['services', 'categories', 'specialists'])->firstOrFail();
        $this->authorizeSpecialist($project, 'view_schedule');
        $date = $request->input('date', now()->format('Y-m-d'));
        $dailySchedule = $project->dailySchedules()->where('date', $date)->first();
        $bookings = $dailySchedule ? $dailySchedule->bookings()->with('service')->get() : collect([]);
        Log::info('SpecialistController::showProject completed', ['bookings_count' => $bookings->count()]);
        return view('specialist.project', compact('project', 'dailySchedule', 'bookings', 'date'));
    }

    public function createProject(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
        ]);
        $project = Project::create([
            'name' => $request->name,
            'description' => $request->description,
            'slug' => Str::slug($request->name),
            'balance' => 0.00,
        ]);
        Auth::guard('specialist')->user()->projects()->attach($project->id, [
            'permissions' => ['manage_schedule', 'view_schedule', 'manage_balance', 'manage_specialists', 'confirm_bookings', 'manual_bookings', 'manage_services'],
            'is_owner' => true,
        ]);
        return redirect()->route('specialist.projects')->with('message', 'Проект создан');
    }

    public function editProject(Request $request, $slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manage_services');
        $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
        ]);
        $project->update([
            'name' => $request->name,
            'description' => $request->description,
            'slug' => Str::slug($request->name),
        ]);
        return redirect()->route('specialist.project', $project->slug)->with('message', 'Проект обновлён');
    }

    public function deleteProject($slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manage_specialists');
        $project->delete();
        return redirect()->route('specialist.projects')->with('message', 'Проект удалён');
    }

    public function inviteSpecialist(Request $request, $slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manage_specialists');
        $request->validate(['email' => 'required|email']);
        $specialist = Specialist::where('email', $request->email)->first();
        $permissions = $request->input('permissions', []);
        $invitation = Invitation::create([
            'project_id' => $project->id,
            'specialist_id' => $specialist ? $specialist->id : null,
            'email' => $request->email,
            'token' => Str::random(32),
            'permissions' => $permissions,
            'status' => 'pending',
        ]);
        Mail::to($request->email)->send(new InvitationMail($invitation));
        return redirect()->route('specialist.project', $slug)->with('message', 'Приглашение отправлено');
    }

    public function managePermissions(Request $request, $slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manage_specialists');
        $request->validate([
            'permissions' => 'array',
            'permissions.*' => 'array',
        ]);
        foreach ($request->permissions as $specialistId => $permissions) {
            $project->specialists()->updateExistingPivot($specialistId, ['permissions' => $permissions]);
        }
        return redirect()->route('specialist.project', $slug)->with('message', 'Права обновлены');
    }

    public function addBalance(Request $request, $slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manage_balance');
        $request->validate(['amount' => 'required|numeric|min:0']);
        $project->increment('balance', $request->amount);
        return redirect()->route('specialist.project', $slug)->with('message', 'Баланс пополнен');
    }

    public function confirmBooking(Request $request, $slug, Booking $booking)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'confirm_bookings');
        $booking->update(['status' => 'confirmed']);
        return redirect()->route('specialist.project', $slug)->with('message', 'Запись подтверждена');
    }

    public function manualBooking(Request $request, $slug)
    {
        $project = Project::where('slug', $slug)->firstOrFail();
        $this->authorizeSpecialist($project, 'manual_bookings');
        $request->validate([
            'client_id' => 'required|exists:clients,id',
            'service_id' => 'required|exists:services,id',
            'date' => 'required|date',
            'start_time' => 'required',
        ]);
        $dailySchedule = $project->dailySchedules()->where('date', $request->date)->firstOrFail();
        Booking::create([
            'project_id' => $project->id,
            'service_id' => $request->service_id,
            'client_id' => $request->client_id,
            'daily_schedule_id' => $dailySchedule->id,
            'start_time' => $request->start_time,
            'status' => 'confirmed',
        ]);
        return redirect()->route('specialist.project', $slug)->with('message', 'Запись добавлена');
    }

    public function bookings(Request $request)
    {
        Log::info('SpecialistController::bookings started', ['params' => $request->all()]);
        $specialist = Auth::guard('specialist')->user();
        $query = Booking::whereIn('project_id', $specialist->projects()->pluck('projects.id'))
            ->with(['project', 'service', 'dailySchedule'])
            ->orderBy('start_time', 'desc');
        if ($request->has('status') && in_array($request->status, ['pending', 'confirmed', 'cancelled'])) {
            $query->where('status', $request->status);
        }
        if ($request->has('date')) {
            $query->whereHas('dailySchedule', function ($q) use ($request) {
                $q->where('date', $request->date);
            });
        }
        $bookings = $query->paginate(10);
        Log::info('SpecialistController::bookings completed', ['bookings_count' => $bookings->count()]);
        return view('specialist.bookings', compact('bookings'));
    }

    public function schedule(Request $request)
    {
        Log::info('SpecialistController::schedule started', ['params' => $request->all()]);
        $specialist = Auth::guard('specialist')->user();
        $projects = $specialist->projects()->pluck('projects.id');
        $schedules = DailySchedule::whereIn('project_id', $projects)
            ->where('date', '>=', now()->startOfDay())
            ->with('workBreaks', 'bookings')
            ->orderBy('date')
            ->get();
        Log::info('SpecialistController::schedule completed', ['schedules_count' => $schedules->count()]);
        return view('specialist.schedule', compact('schedules'));
    }

    public function viewInvitation($token)
    {
        $invitation = Invitation::where('token', $token)->firstOrFail();
        if (Auth::guard('specialist')->check() && $invitation->email === Auth::guard('specialist')->user()->email) {
            return view('specialist.invitation.view', compact('invitation'));
        }
        return redirect()->route('specialist.auth.login')->with('error', 'Авторизуйтесь для просмотра приглашения');
    }

    public function acceptInvitation($token)
    {
        $invitation = Invitation::where('token', $token)->firstOrFail();
        $specialist = Auth::guard('specialist')->user();
        if ($invitation->email !== $specialist->email) {
            abort(403);
        }
        $invitation->update([
            'specialist_id' => $specialist->id,
            'status' => 'accepted',
        ]);
        $invitation->project->specialists()->attach($specialist->id, [
            'permissions' => $invitation->permissions,
            'is_owner' => false,
        ]);
        return redirect()->route('specialist.projects')->with('message', 'Приглашение принято');
    }

    protected function authorizeSpecialist(Project $project, $permission)
    {
        $specialist = Auth::guard('specialist')->user();
        if (!$project->specialists()->where('specialist_id', $specialist->id)->exists()) {
            abort(403);
        }
        $pivot = $project->specialists()->where('specialist_id', $specialist->id)->first()->pivot;
        if (!$pivot->is_owner && !in_array($permission, $pivot->permissions ?? [])) {
            abort(403);
        }
    }
}


========== File: app/Http/Controllers/SpecialistDashboardController.php ==========
<?php
namespace App\Http\Controllers;

use Illuminate\Support\Facades\Auth;

class SpecialistDashboardController extends Controller
{
    public function index()
    {
        $specialist = Auth::guard('specialist')->user();
        $projects = $specialist->projects()->get();
        return view('specialist.dashboard', compact('projects'));
    }
}


========== File: app/Http/Controllers/SpecialistPermission.php ==========
<?php
namespace App\Http\Middleware;

use App\Models\Project;
use Closure;
use Illuminate\Http\Request;

class SpecialistPermission
{
    public function handle(Request $request, Closure $next, $permission)
    {
        $project = $request->route('project');
        $specialist = Auth::guard('specialist')->user();
        if (!$project->specialists()->where('specialist_id', $specialist->id)->exists()) {
            abort(403);
        }
        $pivot = $project->specialists()->where('specialist_id', $specialist->id)->first()->pivot;
        if (!$pivot->is_owner && !in_array($permission, $pivot->permissions ?? [])) {
            abort(403);
        }
        return $next($request);
    }
}
